最长回文子串算法是一种比较常见的动态规划方法的应用算法，$Manacher$算法是一种相对更有且思想基于动态规划的最长回文子串算法，其中时间复杂度为$O(n)$。

#### 中心匹配算法

中心匹配算法的核心是给定字符串与起始点从中心做回文字符串的检验：

```cpp
int expand(string &s, int l, int r)
{
    while (l >= 0 && r < s.size() && s[l] == s[r])
    {
        l--;
        r++;
    }
    return r - l - 2 >> 1;
}
```

要给出起始点的原因是回文串有奇数长度与偶数长度：

- 奇数长度：调用单点开始`expand(s,i,i)`；
- 偶数长度：调用相邻点开始`expand(s,i,i+1)`；

基本思想基于给定一个位置`i`能够得出以它为基点得出的最长奇偶公共子串。

但是在遍历过程中要注意一共要遍历$n$个奇数串（$n$个单点）和$n-1$个偶数串（$n-1$个连续相邻点），最坏情况下（整个串都是一个字母）每个点都要访问到一端触及边界，那么中心匹配算法的时间复杂度为$O(n^2)$，但整个过程只需要保留一个空间记录当前最长的子串的中心点和长度，所以空间复杂度为$O(1)$。

#### Manacher算法

该算法首先要做的就是将字符串的奇偶去掉，这是想到的方法为：将字符串的每个字符之间添加一个其他字符，这里用`#`表示，其中：

- 奇字符串`aaa`可以被添加为`#a#a#a#`使得整个串长度为奇数
- 偶字符串`aa`可以被添加为`#a#a#`使得整个串长度为奇数

上述方法可以在使用中心匹配方法函数时可以只使用`expand(s,i,i)`。

之后的方法描述为：

```cpp
string Manacher(string s)
{
    string new_s = "#";
    for (char c : s)
    {
        new_s += c;
        new_s += "#";
    }
    int n = new_s.size();
    for (int i = 0; i < n; ++i)
    ...
}
```

但可以发现这样的方法只是在操作上去掉了上述意义上的偶字符串但是方法还是没有变化，这时要做的改进是基于动态规划和回文串性质的：

- 学会使用已经存在的条件
- 回文串是关于中心点对称的（这里说的中心点就仅仅是一个单点了）

要记住得一点是算法不是魔法，凭空创造不出来，只能通过基础的改进去拯救丢掉的时间。

所以说利用中心对称很容易想到我们要保留添加补充符号的字符串中每个点的`arm_len`值，这个值的作用就是描述了当前点的最长对称手臂，比如说`bacad`改进后为`#b#a#c#a#d#`，其中`arm_len[c]=3`（这里写`c`是因为字符串中只有一个`c`方便讨论），值为3则说明由`c`出发的回文子串长度为$2×3+1=7$。

上面描述了该算法的时间复杂度是线性的，那么从这个方面出发，一定要维护一个最右边的界`right`表达算法到达字符串最右边的下标，而这个边界一定是当前字符串的臂长所能触及的最右端，从这里同样就引申出了基础变量`center`表达所能触及最右端的臂长所在的中心点位置。

现在算法已经有了基本雏形，有遍历$i$和右边界$right$一定就会有两个问题：

- $right<i$：表达的是当前位置到达边界以外，那么当然就没有值得参照的条件，只能先去调用`expand(s,i,i)`来计算当前点的“手臂”长度

- $right>=i$：表达的是当前位置没有到达边界（被当前的“手臂”覆盖），那么可以根据已有的对称条件计算；

  根据中心点对称可以计算出当前点基于中心点`center`的对称点是$2×center-i$。这条线索能带给我们的是至少可以先通过对称点的`arm_len`值来作为当前点的臂长下界，那么肯定有对称点的臂长很长以至于当前点镜像之后超出右边界的状态，那么`right-i`就作为了臂长上界。

所以实现为：

```cpp
int right = -1;
int center = -1;
vector<int> arm_len;for (int i = 0; i < n; ++i)
{
    int cur_arm_len;
    if (right >= i)
    {
        int minLen = min(right - i, arm_len[2 * center - i]);
        cur_arm_len = expand(new_s, i - minLen, i + minLen);
    }
    else
    {
        cur_arm_len = expand(new_s, i, i);
    }
    arm_len.push_back(cur_arm_len);
    ......
}
```

如此以来就成功的有可能通过已有条件压缩了排查范围，使得排查情况基本都是为了扩展右边界（或者说为了尽快结束）。

但还有最后的问题是如何更新右边界和中心值，那么存在情况为当前点的臂长向右展开已经超过了右边界时，这是需要更新：

```cpp
if (i + cur_arm_len > right)
{
    center = i;
    right = i + cur_arm_len;
}
```

之后得问题就是保留答案了，这点问题不大，当臂长对应的字符串长度大于当前保留的答案时则更新：

```cpp
int start = 0;
int end = -1;
...
if (cur_arm_len * 2 + 1 > end - start)
{
    start = i - cur_arm_len;
    end = i + cur_arm_len;
}
```

最终在线性时间复杂度解决了问题，此外该问题保留了每个点的臂长数据所以相当于是空间换时间，空间复杂度为$O(n)$。



