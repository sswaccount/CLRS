书中在第二十二章图的基本算法中主要提到了以下几个部分：

- 图的表示
- `BFS`
- `DFS`
- 拓扑排序
- 强连通分量

相关算法题目的语言实现操作这里不做阐述，主要实现书中提到的伪代码实现与证明过程：

#### 图的表示

<img src="C:\Users\SSW\AppData\Roaming\Typora\typora-user-images\image-20220327183100049.png" alt="image-20220327183100049" style="zoom:50%;" />

对于$G=(V,E)$主要针对点集为$V$，边集为$E$的有向图和无向图，其中两种标准的方法是邻接链表和邻接矩阵：

- 邻接矩阵可以看作是空间复杂度为$O(V\times V)$的`01矩阵`，当边带权重时则矩阵内部的信息会出现边权取代`01`值；
- 邻接链表通过链表方式记录每个节点连接的邻居节点，空间复杂度为$O(E)$。

有向图与无向图对于邻接矩阵的区别就是当作为无向图时$Matrix(x,y)=Matrix(y,x)$，但空间消耗方面无变化；邻接链表可以理解为对称的把一条边当作两条有向边记录两次，空间小号常数倍增加，在数据量较小时邻接矩阵操作更加灵敏，数据量增加朴素的邻接矩阵效率会低于邻接链表。

更灵活的，算法题目中存图的方式是邻接链表的变种邻接表，相比之下去掉了更加复杂的链表操作用数组映射关系取代。

##### 实现图的表示创建

- 定义三种颜色`VerClolor`（搜索算法书中的理解要求，描述的是搜索中的已完成搜索、临近节点正在搜索和未搜索三种状态）

- 定义链表头节点`Vertex`，其中包含名称、颜色、前驱节点（搜索的一个先后状态）、距离（搜索算法使用参数）和指向后面临边的指针
- 定义`NextNode`结构体用于连接链表头节点或者连接临边结构体

```cpp
enum VerClolor
{
    WHITE,
    GRAY,
    BLACK,
};
struct Vertex
{
    char _name;
    VerClolor _color;
    Vertex *_pi;
    int _d;
    NextNode *_first;
    Vertex(char name = ' ')
        : _name(name),
          _color(WHITE),
          _pi(nullptr),
          _d(0),
          _first(nullptr) {}
};
struct NextNode
{
    char adjvex;
    NextNode *NEXT;
    NextNode(char name = ' ')
        : adjvex(name),
          NEXT(nullptr) {}
};
```

之后创建图类：

其中包含维护点数和边数的参数，构造函数直接读入点的名称数组以便于建图，由于名称不是整型，所以为了方便这部分添加了哈希表维护，因为实际运用名称直接使用下标，所以插入查找哈希表时间复杂度不计入其中。

```cpp
class Graph
{
private:
    int vertex, edge;
    vector<Vertex> G;
    map<char, int> index;

public:
    Graph(int v, int e, char *vs)
        : vertex(v), edge(e)
    {
        for (int i = 0; i < v; ++i)
        {
            G.push_back(Vertex(vs[i]));
            index.insert({vs[i], i});
        }
    }
    void AddEdge(char x, char y, bool flag = false);
};
```

此外添加了方法：`AddEdge()`用于添加边，设置布尔参数的目的是区分是否定义有向图和无向图，添加边的过程有两种情况：

- 当链表头指向临边结构体的指针为空时直接添加数据
- 当链表头指针不空时从指针指向的结构体开始往下查找直到链表指针为空后添加数据

```cpp
void Graph::AddEdge(char x, char y, bool flag)
{
    NextNode *e = new NextNode(y);
    if (G[index[x]]._first == nullptr)
        G[index[x]]._first = e;
    else
    {
        NextNode *p = G[index[x]]._first;
        while (p->NEXT)
            p = p->NEXT;
        p->NEXT = e;
    }
    if (flag)
        AddEdge(y, x);
}
```

#### BFS

广度优先搜索意义就是用队列维护，优先的去先搜索离目标地点最近的节点，所以很容易得出广搜的应用场景包含`最短路径`等等。

这里参照书中的方法和思想所以在节点头中定义了很多看起来和建图无关的信息（颜色、前驱节点、距离）。

广度优先搜索的目的是找出图中所有点距离目标点的最小值，因为该图为无向无权图所以距离指的是单位距离，主要步骤有三个：

<img src="C:\Users\SSW\AppData\Roaming\Typora\typora-user-images\image-20220327213140519.png" alt="image-20220327213140519" style="zoom:50%;" />

1. 将目标点之外的其他节点颜色置为白色，距离设置为无限大，前驱节点指针设置为空；同时将目标点设置为灰色，距离设置为0，由于目标点就是整体图的搜索父节点所以前驱节点也是空；

   ```cpp
   for (auto u : G)
           if (u._name != s)
           {
               u._color = WHITE;
               u._d = 0x7fffffff;
               u._pi = nullptr;
           }
       G[index[s]]._color = GRAY;
       G[index[s]]._d = 0;
       G[index[s]]._pi = nullptr;
   ```

2. 创建队列并放入目标节点开始搜索；

   ```cpp
   queue<char> Q;
   Q.push(s);
   ```

3. 拿出队列头部的节点，对其进行临边的搜索，如果搜索的临边颜色为白色证明它没有被搜索过，或者说这样意味着该搜索过程第一次经过临边节点，这就等同于找到了到达该节点的最近距离。

   之后将该节点颜色改为灰色证明已经作为搜索点的相邻节点被探索过，之后前驱节点改为刚刚拿出的队列头部节点，最后当前节点的距离等于前驱节点距离的值加一（因为这是最近的方式，且无权图距离都是单位长度，为什么是最近的节点之后做细致讨论）。

   直到队列为空搜索结束，每个列表头节点对应的距离也就是距离目标点的最近距离。

   ```cpp
   while (Q.size())
   {
       char u = Q.front();
       Q.pop();
       for (auto v = G[index[u]]._first; v; v = v->NEXT)
           if (G[index[v->adjvex]]._color == WHITE)
           {
               G[index[v->adjvex]]._color = GRAY;
               G[index[v->adjvex]]._d = G[index[u]]._d + 1;
               G[index[v->adjvex]]._pi = &G[index[u]];
               Q.push(v->adjvex);
           }
       G[index[u]]._color = BLACK;
   }
   ```

一切代码以$Github$上传为准，详细阅读原文获得。

最终代码实现上述数据可视化后结果为（图中颜色代表的是距离，颜色越深距离越远）：

![](E:\2022\IA\22.BasicGraph\test.png)

##### 验证广搜最短路径的正确性

首先定义最短路径$\delta(s,v)$是节点`s`到节点`v`的最短路径，若没有通路那就记为$\delta(s,v)=\infty$，注意该处定义的最短路径由于是无权图所以都是单位长度。

> 引理1. 给定有（无）向图$G=(V,E)$，$s$为任意节点，给定任意边$(u,v)\in E$会得到$\delta(s,v)\le \delta(s,u)+1$。

分为两种可能性：

- 当$\delta(s,u)=\infty$时，无论节点`s`到节点`v`的路径是否是通路，结论均成立；
- 当$\delta(s,u)\le\infty$时，节点`s`到节点`v`最短路径必须经过`u`时结论的等式成立，当其路径不经过`u`时，假设有$\delta(s,v)\le \delta(s,u)+1$存在那么可以调整路径到`u`使得情况为等式成立。

总结这个问题就是小于号成立时和条件没关系，否则找`suv`三个点的三角优化（第二种可能性阐述的就是三角优化）关系使得等号成立。

> 引理2.给定有（无）向图$G=(V,E)$，$BFS$给定`s`为搜索目标点，搜索结束时，任意节点$v\in V$得到$v.d\ge\delta(s,v)$。

要明确$\delta(s,v)$指的是理论定义最短路，$v.d$是算法搜索结果的最短路。

证明：

- 假设当前搜索队列中的任意点`u`满足$u.d\ge\delta(s,u)$。

- 搜索队列头部节点`u`的临边进行搜索时存在未被搜索过的白色节点`v`，那么会有赋值$v.d=u.d+1$，根据假设和引理1得到：
  $$
  \begin{aligned}
  v.d&=u.d+1\\
  &\ge \delta(s,u)+1\quad[假设]\\
  &\ge \delta(s,v)\quad[引理1]
  \end{aligned}
  $$

- 节点`v`被染灰色且不会被再次优化，所以结论成立。

归结这个问题就是说搜到的结果一定会不小于定义的最短路，想要证明最短路正确性（任意$v.d=\delta(s,v)$），那么就需要继续证明$v.d\le\delta(s,v)$。

> 引理3.给定有（无）向图$G=(V,E)$，$BFS$搜索中队列节点从队列头开始为：$<v_1,v_2,...,v_r>$，则$v_r.d\le v_1.d+1$且$i\in[1,r-1]$时有$v_i.d\le v_{i+1}.d$。

证明：

- 假设搜索队列初始只含`u`的情况下成立；

- 删除头节点分为两种情况：

  1. 若队列头节点出队后队列为空，那么结论的等式成立；
  2. 否则头节点$v_1$退队前满足$v_1\le v_2$、$v_2\le v_3$和$v_r\le v_1+1$，那么头节点退队后，$v_2$成为新的头节点，满足$v_2\le v_3$和$v_r\le v_1+1\le v_2+1$，说明退队前后据满足结论。

- 添加尾节点分为两种情况：

  1. 若添加节点后队列元素为1，所以结论对应直接成立；

  2. 假定删除头节点$v_0$，那么新头节点为$v_1$，新添加节点为$v_{r+1}$，新的头节点满足$v_1.d\ge v_0.d$；

     因为节点$v_{r+1}$是由节点$v_0$搜索的所以满足$v_{r+1}.d=v_0.d+1\le v_1.d+1$，同样还可以检验$v_r.d\le v_0.d+1$，由上述$v_{r+1}.d=v_0.d+1$得到$v_r.d\le v_{r+1}.d$。

此条引理所表明的表示的实际含义就是队列中最极限的情况就是容纳搜索节点距离为哈密顿距离为`i`的第$i$层节点和距离为哈密顿距离为`i+1`的第$i+1$层节点。

且这两层存在的方式是，第$i$层某个点$v$被搜索出队，那么与$v$相邻的对于搜索目标点来说的第$i+1$层数据才可以入队，这样就保证了队列中头尾距离值$\le 1$。

注：哈密顿距离：两个点$(x_i,y_i)$其中$i=1,2$，距离$D=|x_1-x_2|+|y_1-y_2|$。

> 引理4.$BST$过程中队列中有任意两点$v_i$和$v_j$，且$v_i$在相对靠前的位置那么有$v_i.d\le v_j.d$。

从引理3直接证明得到。

引理4的理解最为贴近常规，和上述的理解维度不同，只需要知道后添加的是同一层元素或下一层元素。

如此看来就可以证明广搜的正确性了：

> 定理：给定有（无）向图$G=(V,E)$，$BST$过程中以$s$为目标点在$G$上搜索，搜索到所有可以到达的节点后算法终止，且任意点$v\in V$有$v.d=\delta(s,v)$。且任意一条$s$出发到$v(v\ne s)$的路径，其最短路径为$s$到节点$v.\pi$的最短路加边$(v.\pi,v)$。

注：其中$v.\pi$表示的是$v$的前驱节点（父节点）。

反证法假设$v$的定义最短路径为$\delta(s.v)$，由引理2得不相等时搜索结果$v.d>\delta(s.v)$：

- 首先排除$v=s(v.d=\delta(s,v)=0)$；

- 接着排除$s$到达不了$v$的情况，因为那样的话定义距离会是无穷；

- 拿出$v$的一个前驱节点$u=v.\pi$，那么有$\delta(s,v)=\delta(s,u)+1$和$u.d=\delta(s,u)$，就会得到：
  $$
  \begin{aligned}
  v.d&>\delta(s,v)\\
  &=\delta(s,u)+1\\
  &=u.d+1\\
  \Rightarrow v.d&>u.d+1
  \end{aligned}
  $$
  那么前驱节点$u$在队列中搜索时可以分为几种情况：

  1. $v$节点为白色时，必定要被$u$节点搜索到且$v.d=u.d+1$则矛盾；
  2. $v$节点为灰色时，存在和$v$的前驱节点$u$距离目标点同层的某节点$w$使得$s$被染色，$w$先于$u$出队且有$v.d=w.d+1$，按照引理4，$w.d\le u.d$则$v.d\le u.d+1$矛盾；
  3. $v$节点为黑色时，说明$v$已经退队了，根据引理4得到$v.d\le u.d$矛盾；

  所以对所有的$v\in V$有$v.d=\delta(s,v)$。之后得结论最短路径可以理解为递归的找一个点距离目标点的最短路径方法。

  在定理证明中搜索队列中的针对颜色的讨论时，可能会不经意间将开始的假设“$u$为$v$的前驱节点”对标讨论情况3发现$v$不可能比前驱节点提前出队而产生这类矛盾，但要注意的是假设是在定义的基础上的，而后续讨论的是算法的正确性，这个问题本身就是要证明的而不需要产生矛盾，类比情况2中可能会把$w$看作是和$u$一样距离目标点同层的节点，而这会得出$w.d=u.d$但要注意的同样是此处说明的是算法的实际情况分析，和定义不应该混淆，只需要利用分情况的算法实践推出矛盾的问题点即可。

##### 广度优先树

首先给定图$G$和目标搜索点$s$的情况下，定义前驱子图$G_\pi=(V_\pi,E_\pi)$，其中点集$V_\pi=\{v\in V|v.\pi\ne NIL\}\bigcup\{s\}$，$E_\pi=\{(v.\pi,v)|v\in V-\{s\}\}$。

可以看出前驱子图表达的是由目标点出发进行搜索，过程中组成的从中心向外的辐射结构，因为边是否在前驱子图内都由点的前驱所决定，如果前驱子图是一棵树而不是森林（不含孤立点，任意点都有最短路包含在前驱子图中），那么前驱子图是一棵广度优先树。

> 引理6. 有/无向图$G=(V,E)$中，$BFS$在每个节点所构建的$\pi$属性使得前驱子图成为一棵广度优先树。

$v.\pi=u$存在当且仅当该前驱到该点的边在图中存在，且该点定义距离目标点不是无穷，所以如果$v$可以由目标点到达，那么这些点$v$就共同构成了$V_\pi$。通过递归运用上节的广搜准确性定理获得了路径是图中的最短路径。

广度优先树的计算也是递归利用上述定理所完成的：

```cpp
void Graph::PrintPath(char s, char v)
{
    if (v == s)
        cout << s << ' ';
    else if (G[index[v]]._pi == nullptr)
        cout << "NO Path" << endl;
    else
    {
        PrintPath(s, G[index[v]]._pi->_name);
        cout << v << ' ';
    }
}
```

利用前驱性质最终输出目标点到输入点的节点路径。

#### DFS(深度优先搜索)

深度优先搜索中定义了另一种前驱子图，其中改动是深搜的点集不包含搜索目标点，这与广搜宽搜的应用场景有很大关系：

- 广搜的应用更多的是查找距离某点最近的距离；
- 而宽搜的目的是作为子程序找到一个答案使其最优；

所以前者搜索从一个目标点出发搜索到数据就结束，而后者更多的是全图搜索，图很可能不是连续的，这也意味着有多个搜索目标点。

##### 搜索算法原理实现

搜索中还需要再每个节点添加“时间戳”表示什么时候开始当前节点、什么时候回溯到当前节点，具体的需要做：

- 当前所有节点颜色定义为白色；
- 从任意一个点开始搜索，开始时将当前节点状态记录开始时间戳并赋为灰色；
- 在灰色节点的白色相邻节点开始继续调用搜索函数；
- 当程序回溯到某个灰色节点时赋为黑色并记录结束时间戳；

可以发现每个节点只有一次机会被搜索开始和搜索回溯，所以时间戳最大值为$2|V|$且开始时间戳$u.d$和结束时间戳$u.f$满足$u.d<u.f$。

并且可以得到在时间轴上：

- $t<u.d$时节点未被搜索为白色
- $t<u.d$时节点的临近节点正在被搜索为灰色
- $t>u.d$时节点已被搜索为黑色

程序实现为：

```cpp
void Graph::DFS()
{
    for (auto i : G)
    {
        i._color = WHITE;
        i._pi = nullptr;
    }
    time = 0;
    for (auto i : G)
        if (i._color == WHITE)
            DFSVisit(i._name);
}
void Graph::DFSVisit(char u)
{
    G[index[u]]._d = ++time;
    G[index[u]]._color = GRAY;
    for (auto v = G[index[u]]._first; v; v = v->NEXT)
        if (G[index[v->adjvex]]._color == WHITE)
        {
            G[index[v->adjvex]]._pi = &G[index[u]];
            DFSVisit(v->adjvex);
        }
    G[index[u]]._color = BLACK;
    G[index[u]]._f = ++time;
}
```

上半部分`DFS()`方法主要任务是将节点初始化且搜索完整个图，图中存在不连通的子图造成单点搜索不能覆盖全图；下半部分`DFSVisit()`方法阐述了上面搜索步骤。

![image-20220329220241618](C:\Users\SSW\AppData\Roaming\Typora\typora-user-images\image-20220329220241618.png)

##### 相关性质

由下图的搜索（先进入$s$进行搜索在进入$t$）可以发现在时间轴上搜索过程描述了一种括号化的结构。

![image-20220329220149332](C:\Users\SSW\AppData\Roaming\Typora\typora-user-images\image-20220329220149332.png)

> [定理]括号化定理：在有向或无向图$G$中进行深搜，对于搜索过程中的任意两个节点`u`和`v`满足三种情况之一：
>
> - $[u.d,u.f]$与$[v.d,v.f]$区间不重合，两个节点不存在父子关系；
> - $[u.d,u.f]$在$[v.d,v.f]$区间内部，$u$是$v$的前驱子图某棵树（也有可能是只有一棵树）中的后代；
> - 第二种情况的镜像；

当$u.d<v.d$情况下有两种情况：

1. 当$v.d<u,f$的时候`v`在搜索中的时候`u`仍为灰色，说明`v`是其后代且`u`的时间戳结束时`v`的状态是已经被搜索完毕，所以$v.f<u.f$证明其是子区间且为后代；
2. 当$v.d>u.f$时，根据不等式有$u.d<u.f<v.d<v.f$，得到两区间完全分离；

镜像情况类似。

> [推论]相应的可以类推到`v`是`u`的后代当且仅当$u.d<v.d<v.f<u.f$不等式存在时成立。

> [定理]白色路径定理：在有向或无向图$G$中进行深搜，`u`是`v`的后代当且仅当在时刻$u.d$存在一条白色节点组成的路径从`u`到`v`。

$\Rightarrow$：$u=v$时刻，算法设计中先定义时间再覆盖灰色所以自身还是白色成立；$v$为任意后代都满足上述类推$u.d<v.d$那么后续节点都为白色。

$\Leftarrow$：假定$v$不为$u$的后代且是搜索之后第一个不是$u$后代的节点，但存在一条白色路径，这样的话设$w=v.\pi$，那么有$w.f\le u.f$（推论成立，等号存在当且仅当$u=w$），因为$w=v.\pi$所以作为前驱要满足$v.f<w.f$同理推得`v`的时间戳区间被限制在`u`的区间内则满足定理的条件。

##### 边的分类

$G(V,E)$在基于深搜定义下的前驱子图$G_\pi$（又称深度优先森林）中定义了四种类型的边:

- `树边`均为深度优先森林的边（$E_\pi$）；
- `后向边`为$E$中非树边且将节点连向祖先节点的边（自循环的边被认为是后向边）；
- `前向边`为后向边的反向描述，连接向后代节点的边；
- `横向边`为所有其他类型的边，包含同一树中非祖先、深搜森林中连接两棵树的边等等；

![image-20220330171155471](C:\Users\SSW\AppData\Roaming\Typora\typora-user-images\image-20220330171155471.png)

对应上节验证括号化定理的深搜的前驱子图可以得出，粗线描述的都为树边构成了前驱子图，标注为`B`为的是连接祖先的后向边，标注`F`是连接后代的前向边，而标注`C`的是横向边。

其中书中讨论的情况为：搜索过程中第一次探索$(u,v)$边时，通过节点颜色可以得出该边的类型：

1. 节点`v`为白色：树边；

   情况很容易得证，因为白色时会被添加到前驱子图使得$(u,v)\in E_\pi$。

2. 节点`v`为灰色：后向边；

   不同于书中讨论：当在搜索中访问相邻节点只会有两个状态：

   - 访问节点为图中其他搜索树的节点，那么因为当前的树搜索未完成，其他树的状态有两种，一种是整棵树未被搜索节点为白色，这时可以将访问到的节点归纳到当前节点所在的树中；另一种情况是访问节点所在的树已经被搜索过，那么树的颜色应为黑色，与上述条件不符；
   - 访问节点为图中当前搜索树的节点，有两种状态，若为白色时这种情况归纳到第一种情况为树边；若为灰色时说明找到了该树中搜索还未回溯的节点$x$且节点$x$通过递归调用搜索找到了当前节点并形成了环访问回到了$x$，这是可以证明`x`为节点`v`的祖先；若节点为黑色说明访问到的节点不是当前搜索树，与前提矛盾不考虑。

3. 节点`v`为黑色：前向边或横向边；

   依旧分为两种可能性：

   - 若是一棵树中的节点，分为了两类情况，一类为上图$s\rightarrow w$的指向后代的前向边，另一类是$w\rightarrow x$没有直系亲缘关系的横向边；
   - 若不是一棵树中的节点，那么就只能归类为横向边。

在上述过程中的问题是深搜算法是一个在应用中全局搜索找答案的方法，所以边的性质可能不是唯一的，要针对顶点链表的顺序去看，但上述边的分类是基于深搜后的前驱子图的而不是待搜索的图。

> [定理]在无向图搜索中，任意一条边要么是树边，要么是后向边。

搜索边$(u,v)$的过程中，若节点`v`未被搜索过，那么根据上述判断边$(u,v)$为树边；反之如果节点`v`被搜索过那么说明算法通过$(v,u)$完成了第一次搜索，则`u`为后代，边$(u,v)$为一条连接祖先的后向边。

问题：$(u,v)$在访问节点`v`为黑色时有性质：$u.d<v.d$时边为前向边，$u.d>v.d$时边为横向边。

该问题情况三的讨论1中做了举例描述，可以尝试进行证明。

#### 拓扑排序

对于有向无环图$G=(V,E)$，拓扑排序的效果是将所有顶点集合进行线性排序，排序与数据的大小排序不同，拓扑排序更多的是依赖于节点间的方向关系，或者解释为是“先有鸡还是先有蛋”的故事，将蛋生鸡，鸡生蛋这种拓扑的顺序结构转变为线性结构“就是“蛋变成鸡”这种排序效果，更多的可能会应用到工程流程上或是其他领域。

上述举得例子不合理因为针对有向无环图，图中存在环则意味着无法找到一个不被依赖的节点提取出来，所以”蛋变成鸡“这种线性结果是存在矛盾的。

![](C:\Users\SSW\Desktop\topo_before.png)

上述拓扑图是书中的例子，描述的是每天起床穿衣服的步骤，可以看到手表随时都可以戴，但夹克要依赖于领带和腰带继而依赖衬衣等等。

所以说拓扑排序的主要流程就是找到一个没有入边的节点拿出来然后反复这个过程去解决一个拓扑问题从而提出线性的结果。

- 普遍的拓扑排序做法是：找到一个没有入度的节点放入队列，将其所有的出边对应的节点放进队列，之后输出该节点，直到队列为空，排序完成；
- 书中针对原理的描述是：在拓扑图中进行深度优先搜索，每个节点均有且只有一次被标记为黑色状态的机会，标记黑色表示的是该节点及其它的后代节点都已经完成搜索（实际情况下有可能该节点是边界点没有后代），所以标记为黑色又可以描述是没有非黑色后代或者说没有后代未完成搜索的依赖，尤其是作为有向无环图的情况下。所以根据原理采用拓朴排序的另一个实现方法是在节点深搜结束时（记录结束时间戳后）将节点加入数组，最后将数组输出即为排序结果；

```cpp
void Graph::DFSVisit(string u, bool flag)
{
    ... ...
    if (flag)
    {
        topo.push_back(u);
    }
}
```

最终输出`topo`数组即可，最终根据上述的穿衣服流程和该代码实现结果为：

![](C:\Users\SSW\Desktop\topo.png)

上述数据结果是反向的，拓扑排序的结果有多种可能，只需要满足条件（依赖关系）就可以。

> 引理11. 有向图$G=(V,E)$是无环的当且仅当对其深度优先搜索不产生后向边。

$\Rightarrow$：如果产生了后向边，那么说明产生了环，矛盾；

$\Leftarrow$：假定对$G$搜索产生了环路，环路中有$v$节点开始搜索，并有一条路径$(u,v)$，在$v.d$时刻图中有一条`v`到`u`的白色路径，则根据白色路径定理，$u$为后代节点，则$(u,v)$为后向边，矛盾；

> [定理]拓扑排序算法生成的是有向无环图的拓扑排序。

上述拓扑排序算法描述中针对的是$DFS$的结束时间，问题等价于针对图中的任意边$(u,v)$总有$v.f<u.f$；那么针对边$(u,v)$进行搜索时：

- 节点为灰色则产生后向边与引理矛盾；
- 节点为白色则进行搜索成为后代得到$v.f<u.f$；
- 节点为黑色则$u$需要进行探索别的子节点或者探索完成得到$v.f<u.f$；

#### 强连通分量

强连通分量将整个图分为一个或多个节点集合，其中每个集合中的节点在图中互通，下图给定了样例。$(c)$图表示的是$G^{SCC}$将图的强连通分量收缩为一个点。

![](C:\Users\SSW\Desktop\强连通分量.png)

算法过程主要依托三步：

- 对图进行深搜；
- 建反向图$G^T(V,E^T)$，使得$E^T=\{(u,v)|(v,u)\in E\}$；
- 在反向图上依照第一步深搜的时间戳的递减顺序进行搜索；

最终输出查找到的强连通分量。分量图的一大性质：$G^{SCC}$是有向无环图。

> 引理13.$C$和$C'$为有向图的不同强连通分量，$u，v\in C$，$u'，v'\in C'$，假定图中含有向边或路径$u\rightarrow u'$，那么图中一定不含有向边或路径$v'\rightarrow v$。

如果成立，那么$C$和$C'$是不同的强连通分量则矛盾。

针对第一次搜索结果定义对于集合的时间戳，若节点集和$U\subseteq V$：

- $d(U)=min_{u\in U}(u.d)$
- $f(U)=max_{u\in U}(u.f)$

> 引理14.$C$和$C'$为有向图的不同强连通分量，若存在边$(u,v)\in E$且$u\in C,v\in C'$，则$f(C)>f(C')$。

两种情况讨论：

1. $d(C)>d(C')$时说明前者先进行搜索，在开始搜索时设节点为$x$，两个连通分量集合的节点颜色都为白色，且都存在路径，白色路径定理得到开始搜索的节点为两个集合的节点的祖先，所以得到$x.f=d(C)>d(C')$；
2. $d(C)<d(C')$时说明后者先进行搜索，在$C'$开始中搜索时设节点$y$，同理$y$是$C'$集合所有节点的祖先，且存在$C\rightarrow C'$的路径那么根据`引理13`得到不存在$C'\rightarrow C$的路径，所以$y.f$时刻时$C$中节点都为白色，所以$f(C)>f(C')$。

>引理15.$C$和$C'$为有向图的不同强连通分量，若存在边$(u,v)\in E^T$且$u\in C,v\in C'$，则$f(C)<f(C')$。

注意，这里的`f()`表达的是上面定义的针对第一次搜索的时间戳。

在边集合$E$中存在边$(v,u)$使得$C'\rightarrow C$，由`引理14`得到相反结论$f(C)<f(C')$。

> [定理]以上表述的算法过程能够计算出正确的有向图强连通分量。

归纳假设法确定：第$0$棵树和第$k$棵树都是强连通分量，那么考虑$k+1$棵树：

该树根节点为$u$，该节点处在强连通分量$C$中，初始在反向图搜索中任何一个连通分量$C$中的节点都是可达的（白色路径定理）。且反向图中该连通分量额外最多会到达前$k$个连通分量（这里的到达不是进入，而是访问到判断黑色的状态），因为第二次搜索是依照第一次时间戳递减进行的，所以对于任意未搜索的强连通分量$C'$，存在$f(C)>f(C')$，那么图中一定不存在到达任意未搜索强连通分量节点的边（如果反向图可以到达的情况下`引理15`得到与之矛盾的$f(C)<f(C')$）。

所以$u$能访问到的节点集合就是其对应的强连通分量。

##### 原理实现

根据上述图传入数据：

![](C:\Users\SSW\Desktop\+.png)

建立反向边：

![](C:\Users\SSW\Desktop\-.png)

带入强连通分量的算法计算：

```cpp
void Graph::StronglyConnectedComponents()
{
    DFS(true);
    reverse(topo.begin(), topo.end());
    
    for (auto i : GT)
    {
        i._color = WHITE;
        i._pi = nullptr;
    }
    time = 0;
    for (auto i : topo)
    {
        if (GT[index[i]]._color == WHITE)
        {
            DFSVisit(GT[index[i]]._name);
            cout << endl;
        }
    }
}
```

最终在第二次搜索结束时输出每个强连通分量的集合节点，输出结果为：

```
e a b
d c
g f
h
```

相关所有源代码均上传至$Github$，点击原文获取。
