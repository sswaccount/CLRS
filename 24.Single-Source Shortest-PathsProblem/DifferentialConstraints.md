#### 差分约束系统

差分约束系统主要服务的对象是`m`个约束条件涉及`n`个随机变量的差额限制条件，每个约束条件可以表达为线性不等式：
$$
x_i-x_j\le b_k
$$
这里`x`为随机变量，共有`m`个限制所以`k`的取值范围是`[1,m]`，使用矩阵可以表达为：
$$
A_{m\times n}· x_{1\times n}=b_{m\times 1}
$$
其中矩阵$A$的要求为每行只包含一个`1`和一个`-1`。

实际例子表达为：

![](C:\Users\SSW\Desktop\DC1.png)

上述矩阵表达等价于线性不等式组形式：
$$
\begin{aligned}
&x_{1}-x_{2} \leq 0\\
&x_{1}-x_{5} \leq-1\\
&x_{2}-x_{5} \leq 1\\
&x_{3}-x_{1} \leq 5\\
&x_{4}-x_{1} \leq 4\\
&x_{4}-x_{3} \leq-1\\
&x_{5}-x_{3} \leq-3\\
&x_{5}-x_{4} \leq-3
\end{aligned}
$$
从图论角度分析差分约束系统，可以将图$G=(V,E)$理解为包含`n`个节点`m`条边的有向图，其中点集合和边集合分别表示为：
$$
\begin{aligned}
V&=\{v_0,v_1,...,v_n\}\\
E&=\{(v_i,v_j)|x_j-x_i\le b_k\}
\end{aligned}
$$
其中每条边的边权表达为$b_k$，且边集合应在上述描述基础上加入各个点与$v_0$的连接，拓扑图表达为：

<img src="C:\Users\SSW\Desktop\DC2.png" style="zoom:25%;" />

##### 讨论边的方向：

假设$(x_j,x_i)$作为有向边的方向确定准则，在不等式的约束中进行转化为：
$$
x_j\le x_i+b_k
$$
当$b_k$作为边权时，不等式所表达的意义更多的是做了一个权值上的合成，类比在单源最短路径中查询时，抽象后会发现也有这类计算概念。

而在单源最短路径中更强调的是判断是否存在需要优化的此类情况：
$$
x_j> x_i+b_k
$$
若存在即优化至等式状态，若不存在则无视，所以在松弛方法中的结论很巧妙的套在了不等式约束的概念中，换句话说其概念强调的状态在定义的方向下就是松弛方法所要追求的答案。

##### 优化`Bellman-Ford`

由于图中存在负权边，那么首先考虑的方法是第一节中描述的`Bellman-Ford`算法，由上述拓扑图描述添加了`n`条边权为零且指向未知量的节点（因为最短路径查找过程中需要提供一个源节点）。

> [引理]向量$x_{1\times n}$为差分约束系统的一个解，那么存在$d\in R$使得$x+d$也是系统的一个解。

其中向量对常数的加法可以理解为按位依次添加：对于任意两个未知量$x_i$和$x_j$都满足下式：
$$
(x_i+d)-(x_j+d)=x_i-x_j
$$
所以上述引理成立。

那么向拓扑图中添加权值为零的`n`条边等价于向系统中对`n`个未知量做了如下`n`个额外约束：
$$
x_i-x_0\le 0,i\in[1,n]
$$
根据上述约束添加了边$(v_0,v_i)$且$v_0.d=0$，那么根据引理说明添加这些边并未对系统结果产生影响，其作用是为单源最短路径方法提供源节点，所以根据上述数据进行计算可以得到最终答案，但是其时间复杂度为：
$$
O((n+1)(n+m))
$$
因为图中的额外添加导致了复杂度的微小幅度上升，但这里考虑不含源节点定义的方式，或者说提前在数据初始化过程中摒弃源节点的方式：

- 因为给定源节点时是按照算法的思想进行的，但内容上源节点属性值为0，到达未知量点的边权为0。
- 在初始化过程中对所有未知量对应的节点赋初始值为0。

实质上是依旧存在源节点的但是在预处理中进行了提前操作优化了部分计算过程。

如此操作直接在图中进行$|V|-1$次全局边的遍历松弛操作得到答案，其时间复杂度会优化至$O(mn)$。

同时利用`Bellman-Ford`方法的好处不仅仅是求差分约束系统的通解，更有意义的是可以根据负环的判断返回值来确定差分约束系统是否存在解。

改进的初始化方法为：

```cpp
void Graph::InitDiff()
{
    for (auto &i : G)
    {
        i._d = 0;
        i._pi = nullptr;
    }
}
```

改进的`Bellman-Ford`方法变化则只是调整了初始化部分：

```cpp
bool Graph::BellmanFord()
{
    InitDiff();
    for (int i = 1; i < vertex; i++)
        for (auto it : weight)
            Relax(it.first.first, it.first.second);
    for (auto it : weight)
        if (G[index[it.first.second]]._d > G[index[it.first.first]]._d + it.second)
            return false;
    return true;
}
```

最终根据上述样例求解结果为：

```cpp
a -5
b -3
c 0
d -1
e -4
```

##### 求解差分约束系统正确性

> 给定差分约束系统$Ax\le b$，图$G$是差分约束系统对应的约束图，若图中不包含负权环边，那么：
> $$
> x=\left(\delta\left(v_{0}, v_{1}\right), \delta\left(v_{0}, v_{2}\right), \delta\left(v_{0}, v_{3}\right), \ldots, \delta\left(v_{0}, v_{n}\right)\right)
> $$
> 是系统的可行解，若存在负权环边则不存在解。

若不存在负权环边，那么根据三角不等式性质得到任意的两点满足：
$$
\delta\left(v_{0}, v_{j}\right) \leq \delta\left(v_{0}, v_{i}\right)+w\left(v_{i}, v_{j}\right)
$$
移项后设$x_i=\delta(v_o,v_i)$得到：
$$
x_j-x_i\le w(v_i,v_j)
$$
所以其满足差分约束条件的内容。

若存在负权环边，设环边为$p$：
$$
p= <v_1,v_2,...,v_k>
$$
因为$v_0$为源节点依据构造方法得到其一定不存在环边，所以$p$环边中首尾节点相同，根据上述符合条件下的差分约束内容：
$$
x_j-x_i\le w(v_i,v_j)
$$
得到环路上的所有边涉及的不等式：
$$
\begin{aligned}
x_{2}-x_{1} & \leq w\left(v_{1}, v_{2}\right) \\
x_{3}-x_{2} & \leq w\left(v_{2}, v_{3}\right) \\
& \vdots \\
x_{k-1}-x_{k-2} & \leq w\left(v_{k-2}, v_{k-1}\right) \\
x_{k}-x_{k-1} & \leq w\left(v_{k-1}, v_{k}\right)
\end{aligned}
$$
叠加后得到左侧环形裂项相消求和为0，右侧为环路权重$w(p)$，推得结果：
$$
w(p)\ge 0
$$
这与假设的负权环边中的$w(p)<0$相矛盾，所以正确性成立。