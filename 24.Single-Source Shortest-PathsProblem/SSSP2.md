#### Dijkstra算法

该算法的要求是在一张带权图$G=(V,E)$中，满足边权：
$$
(u,v)\in E\\
w(u,v)\ge0
$$
相比于`Bellman-Ford`算法条件更强，但好处是其运行时间进行了大大优化。

进一步说不带权重的图将退化为`BFS`方法而不是不能使用该方法（效率问题）。`Dijkstra`算法给定源节点`s`的背景下采用优先队列方式优化问题：

- 初始化操作未进行改动；

  ```cpp
  InitializeSingleSource(s);
  ```

- 将所有点依据`d`属性值作为关键字加入至优先队列`Class<Heap>`中并构建小根堆；

  ```cpp
  Q = new Heap(G);
  Q->BuildMinHeap();
  ```

- 每次将堆顶元素弹出并访问其所有相邻节点，之后进行每个临边的松弛操作；

  ```cpp
  while (!Q->empty())
      {
          Vertex u = Q->HeapMinimum();
          Q->HeapExtractMin();
          string inx = u._name;
          for (auto v = G[index[inx]]._first; v; v = v->NEXT)
          {
              Relax(inx, v->adjvex);
          }
      }
  ```

- 松弛操作过程中需要进行更新小根堆的键值（在原松弛方法中做一定的修正）；

  ```cpp
  void Graph::Relax(string u, string v, bool flag)
  {
      if (G[index[v]]._d > G[index[u]]._d + weight[{u, v}])
      {
          G[index[v]]._d = G[index[u]]._d + weight[{u, v}];
          G[index[v]]._pi = &G[index[u]];
          if(flag)
              Q->HeapDecreaseKey(v, G[index[v]]._d);
      }
  }
  ```

在算法思想中需要设定集合`S`使其在优先队列弹出元素时添加进集合`S`中，且集合被定义为是已经完成最短路径查询的节点组成的集合，但在实际操作中可以进行一定程度的舍弃（如果图比较理想）。

![](C:\Users\SSW\Desktop\22222222222222222222222222222222.png)

添加输出流友元函数重载了`<<`运算符：

```cpp
ostream &operator<<(ostream &os, Graph data)
{
    for (auto i : data.G)
        os << i._name << ' ' << i._d << endl;
    return os;
}
```

依照上述样例运行得到：

```cpp
    Graph g = Graph(5, 10, sname);
    g.AddEdge(...);
    g.Dijkstar("s");
    cout << g << endl;
```

最终输出结果一致：

```cpp
s 0
t 8
x 9
y 5
z 7
```

##### 算法正确性

> Dijkstra算法正确性：带权重的有向图$G=(V,E)$中所有权重非负，在算法终止时满足$u.d=\delta(s,u)$。

维护的循环不变式：在优先队列非空的情况下循环开始时，在集合`S`中的节点满足：
$$
v.d= \delta(s,v)
$$

1. 初始化：集合`S`为空集则直接成立；

2. 保持：对于刚加入的`u`节点来说，要求满足上式，反证：`u`是第一个不满足该循环不变式的节点。

   源节点首先加入集合`S`，所以当节点`u`加入集合时总存在一条由源节点出发的路径，反之如果加入后不存在路径，那么其定义和计算属性值相等且为$\infty$，这将满足循环不变式的相等条件矛盾。

   ![](C:\Users\SSW\Desktop\111111111111111111111.png)

   所以构造一条最短路径，其中`y`为集合`S`外部在路径上的第一个节点，`x`为`y`的前驱，则其路径$p$被分解为：
   $$
   s \stackrel{p_{1}}{\sim} x \rightarrow y \stackrel{p_{2}}{\sim} u
   $$
   其中`x-y`是一条边，$p_1p_2$可能不存在，当节点`u`加入到集合中时，可以发现：
   $$
   y.d=\delta(s,y)
   $$
   因为`u`是第一个不满足循环不变式的节点，且`x`节点加入了集合`S`满足不变式，在`x`临边在最短路径上被松弛后，根据收敛定理可以发现上述`y`节点一定满足循环不变式。

   由于最短路径$p$中`y`节点在`x`节点前，所有边权非负，所以有定义的$\delta$有递增关系：
   $$
   \delta(s,y)\le\delta(s,u)
   $$
   所以有不等式成立：
   $$
   \begin{aligned}
   y \cdot d &=\delta(s, y) \\
   & \leq \delta(s, u) \\
   & \leq u . d
   \end{aligned}
   $$
   在队列中弹出节点`u`时，`y`也在队列中，由于边权非负所以满足不等式：
   $$
   u.d\le y.d
   $$
   综合所描述的内容可以发现`u==y`且`y`满足循环不变式，最终得到证明成立。

3. 终止：优先队列元素为空，集合`S`内部节点等价于`V`集合，所以满足循环不变式要求；

###### 个人想法：

上述保持过程中描述的`y`也在队列中得到另一组不等式，换句话解释是因为若在`u`弹出队列时，`y`已经在集合中了，那么问题将退化为`u`是第一个在路径上不在集合内的节点，根据`y`关于满足循环不变式的证明同样成立。

但这里没有分两种情况描述的原因是在前期已经固定了`y`和`u`在集合之外且想要通过反证法寻找问题的矛盾点，合理的递归证明为了便捷不涉及其中。

##### 复杂度分析

遍历邻接链表的过程以知每个节点访问一次且访问了当前节点的所有有向临边，所以基础执行次数为$|E|$次。

采用二叉堆优先队列优化寻找队列中最大值算法，构建堆复杂度为$O(V)$，之后获取最小元素要获取$|V|$次，每次时间复杂度为$logV$，在修改关键字数据上，最多需要每条边做修改$|E|$次，每次时间复杂度为$logV$，所以归纳结果为$O((V+E)logV)$。

使用斐波那契堆可以优化到$O(VlogV+E)$这里不做讨论。

代码阅读原文获取。