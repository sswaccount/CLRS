#### 不相交集合的数据结构

> 定义：将集合$A$分成一些非空子集，每个子集称为一个类，且$A$中每个元素仅属于一个类。则称这些类的全体为集合$A$的一个分类，也称$A$的一个分划。

从近世代数描述分类的定义中进行实例化，可以看到不相交集合的影子，其中集合$A$维护的关系为集合森林的强连通分量子集，每个节点仅属于一个连通分量的分类中。

针对上述不相交集合，初始化为均是单个节点的森林，所以实现其他连通分集合的操作有三种：

- `Make-set(x)`：初始化新的集合，该集合只包含`x`；
- `Union(x,y)`：将两个连通集合做合并；
- `Find-set(x)`：返回集合所包含的代表元素；

在分类中表示为$S_i$其中集合中任意元素都可以作为代表元素，依照性质，更多的把集合的树根作为集合的代表元素；

连通分量和树根在这里并不矛盾，因为连通分量在此处指的是区块内部元素属于一个分类，可以由根节点到达，而整个集合被分划为多颗树，且根节点是被定义的而不是说任意连通分量都由一棵树组成。

更多的，做不相交集合操作更多的是基于一张无向图$G=(V,E)$，例如在如下过程中：

<img src="C:\Users\SSW\Desktop\eg.png" style="zoom:33%;" />

其中提供针对的参数是所有的$E$遍历使得找到图最终分有几个分类；

<img src="C:\Users\SSW\Desktop\code.png" style="zoom:33%;" />

伪代码提供了两个函数，分别为针对图的连接函数和判断两节点是不是同一分类的函数其中内部函数表示基于后续的数据结构方法介绍。

##### 朴素的链表表示方法

![](C:\Users\SSW\Desktop\链表.png)

链表表示

- 集合使用两个指针维护该集合的线性头部元素和尾部元素
- 在集合中的元素额外头指针指向集合头部，尾指针指向线性关系的下一个元素

由此看出创建`Make-set(x)`与`Find-set(x)`的时间复杂度都是$O(1)$时间内完成的，其次合并方法`Union(x,y)`的操作流程要更多一些，在线性表的情况下需要将`y`集合内部的元素一个一个的加在`x`集合上。

使用摊还分析计算上述三个操作序列：

由于合并操作要基于图中的非连通块，`Make-set`操作的调用次数为$n$次，`Union`函数的调用次数至多为$n-1$次，且查询集合的方法通常不单独使用。

要求解实际代价的上界代价，所以假设在合并操作中要将更长的链表叠加在短链表中，如此调用$n-1$次之后，在$2n-1$的操作序列中摊还代价时间复杂度为$O(n^2)$，所以平均的操作的摊还时间为$O(n)$。

上述问题很明显看出优化策略在合并过程中，其中调整为使用较短链作为转移链，所以能得到如下定理：

> 定理：使用不相交集合的链表表示和加权合并启发式策略。长度为$m$的操作序列需要的时间为$O(m+nlgn)$

使用逆向二分的思想，首先合并长度为1的链表，其次长度为2的，长度为4、8、16直到集合被合并完全，类比归并排序，时间复杂度解释为$O(nlgn)$，加上线性操作的时间，整个操作序列时间为$O(m+lgn)$。

##### 不相交集合森林

朴素指针简化后表现为树的形式：

![](C:\Users\SSW\Desktop\tree.png)

每个分类集合的代表元素表现为树根节点，图表示了`Union(c,f)`合并的结果，下面介绍基于树表示的两个优化思路：

###### 按秩合并

在树的合并中规定树高，在合并过程中只需要将待合并的高度较低的树根的父指针指向合并树的树根，从而确保维护树高的上界。

###### 路径压缩

<img src="C:\Users\SSW\Desktop\压缩路径.png" style="zoom:33%;" />

在查询方法`Find-set()`调用过程中递归的将子树的根节点指向合并后的根节点，该过程不改变集合森林任意节点的秩，此处不改变的原因是秩表现得是上界，而该操作是让树高变低的操作。

带路径压缩的按秩合并操作实现方法为：

```cpp
class DisjiontSet
{
private:
    int n;
    vector<int> p;
    vector<int> rank;
    int FindSet(int x)
    {
        if (p[x - 1] != x)
            p[x - 1] = FindSet(p[x - 1]);
        return p[x - 1];
    }
    void Link(int x, int y)
    {
        if (rank[x - 1] > rank[y - 1])
            p[y - 1] = x;
        else
        {
            p[x - 1] = y;
            if (rank[x - 1] == rank[y - 1])
                rank[y - 1]++;
        }
    }
public:
    DisjiontSet(int num = 0)
        : n(num)
    {
        for (int i = 1; i <= num; ++i)
        {
            p.push_back(i);
            rank.push_back(0);
        }
    }
    void Union(int x, int y)
    {
        Link(FindSet(x), FindSet(y));
    }
    void show()
    {
        cout << "parent: ";
        for (auto i : p)
            cout << i << ' ';
        cout << endl<<"rank  : ";
        for (auto i : rank)
            cout << i << ' ';
        cout << endl;
    }
};
```

程序中为了简洁表达采用两个数组表示节点的属性，之后将初始化自动置入构造函数中，详细逻辑内容参照书中伪代码，`show()`函数方便进行检验：

```cpp
DisjiontSet x = DisjiontSet(3);
x.show();
x.Union(1, 2);
x.show();
x.Union(1, 3);
x.show();
```

进行两次合并操作显示各个节点的父节点和秩为：

```
parent: 1 2 3 
rank  : 0 0 0
parent: 2 2 3
rank  : 0 1 0
parent: 2 2 2
rank  : 0 1 0
```

详细代码点击原文获取